package draw;

/**
 * @program: leetcode
 * @description: 924
 * @author: Skyler
 * @create: 2024-04-16 14:24
 **/

public class MinMalwareSpread {
    //找到的最大连通块的罪魁祸首节点，和删除当前罪魁祸首节点后变成好节点的数量（即连通块大小）
    int currentNodeId, size;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        boolean[] visited = new boolean[graph.length];
        boolean[] isInitial = new boolean[graph.length];
        int minValue = Integer.MAX_VALUE;
        //初始化初代病毒数组
        for (int i:
             initial) {
            isInitial[i] = true;
            minValue = Math.min(minValue, i);
        }

        //被删除的节点
        int ans = -1;
        //节点删除后
        int maxRemove = 0;
        for (int i:
             initial) {
            if (visited[i]) continue;
            size = 0;
            currentNodeId = -1;

            dfs(i, graph, visited, isInitial);

            if (currentNodeId > 0 && (size == maxRemove && currentNodeId < ans || size > maxRemove)){
                ans = currentNodeId;
                maxRemove = size;
            }

        }
        return ans < 0 ? minValue : ans;
    }

    public void dfs(int x, int[][] graph, boolean[] visited, boolean[] isInitial){
        visited[x] = true;
        size++;
        if (currentNodeId != -2 && isInitial[x]){
            currentNodeId = currentNodeId == -1 ? x : -2;
        }
        for (int i = 0; i < graph[x].length; i++) {
            if (graph[x][i] == 1 && !visited[i]){
                dfs(i, graph, visited, isInitial);
            }
        }
    }
}
